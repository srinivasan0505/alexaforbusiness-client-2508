/*
 * Alexa For Business
 * Alexa for Business has been retired and is no longer supported.
 *
 * The version of the OpenAPI document: 2017-11-09
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ConferenceProviderType;
import org.openapitools.client.model.CreateConferenceProviderRequestIPDialIn;
import org.openapitools.client.model.CreateConferenceProviderRequestMeetingSetting;
import org.openapitools.client.model.CreateConferenceProviderRequestPSTNDialIn;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An entity that provides a conferencing solution. Alexa for Business acts as the voice interface and mediator that connects users to their preferred conference provider. Examples of conference providers include Amazon Chime, Zoom, Cisco, and Polycom. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T13:07:53.324908+05:30[Asia/Kolkata]", comments = "Generator version: 7.10.0")
public class ConferenceProvider {
  public static final String SERIALIZED_NAME_ARN = "Arn";
  @SerializedName(SERIALIZED_NAME_ARN)
  @javax.annotation.Nullable
  private String arn;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nullable
  private String name;

  public static final String SERIALIZED_NAME_TYPE = "Type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  @javax.annotation.Nullable
  private ConferenceProviderType type;

  public static final String SERIALIZED_NAME_IP_DIAL_IN = "IPDialIn";
  @SerializedName(SERIALIZED_NAME_IP_DIAL_IN)
  @javax.annotation.Nullable
  private CreateConferenceProviderRequestIPDialIn ipDialIn;

  public static final String SERIALIZED_NAME_PS_T_N_DIAL_IN = "PSTNDialIn";
  @SerializedName(SERIALIZED_NAME_PS_T_N_DIAL_IN)
  @javax.annotation.Nullable
  private CreateConferenceProviderRequestPSTNDialIn psTNDialIn;

  public static final String SERIALIZED_NAME_MEETING_SETTING = "MeetingSetting";
  @SerializedName(SERIALIZED_NAME_MEETING_SETTING)
  @javax.annotation.Nullable
  private CreateConferenceProviderRequestMeetingSetting meetingSetting;

  public ConferenceProvider() {
  }

  public ConferenceProvider arn(@javax.annotation.Nullable String arn) {
    this.arn = arn;
    return this;
  }

  /**
   * Get arn
   * @return arn
   */
  @javax.annotation.Nullable
  public String getArn() {
    return arn;
  }

  public void setArn(@javax.annotation.Nullable String arn) {
    this.arn = arn;
  }


  public ConferenceProvider name(@javax.annotation.Nullable String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nullable String name) {
    this.name = name;
  }


  public ConferenceProvider type(@javax.annotation.Nullable ConferenceProviderType type) {
    this.type = type;
    return this;
  }

  /**
   * Get type
   * @return type
   */
  @javax.annotation.Nullable
  public ConferenceProviderType getType() {
    return type;
  }

  public void setType(@javax.annotation.Nullable ConferenceProviderType type) {
    this.type = type;
  }


  public ConferenceProvider ipDialIn(@javax.annotation.Nullable CreateConferenceProviderRequestIPDialIn ipDialIn) {
    this.ipDialIn = ipDialIn;
    return this;
  }

  /**
   * Get ipDialIn
   * @return ipDialIn
   */
  @javax.annotation.Nullable
  public CreateConferenceProviderRequestIPDialIn getIpDialIn() {
    return ipDialIn;
  }

  public void setIpDialIn(@javax.annotation.Nullable CreateConferenceProviderRequestIPDialIn ipDialIn) {
    this.ipDialIn = ipDialIn;
  }


  public ConferenceProvider psTNDialIn(@javax.annotation.Nullable CreateConferenceProviderRequestPSTNDialIn psTNDialIn) {
    this.psTNDialIn = psTNDialIn;
    return this;
  }

  /**
   * Get psTNDialIn
   * @return psTNDialIn
   */
  @javax.annotation.Nullable
  public CreateConferenceProviderRequestPSTNDialIn getPsTNDialIn() {
    return psTNDialIn;
  }

  public void setPsTNDialIn(@javax.annotation.Nullable CreateConferenceProviderRequestPSTNDialIn psTNDialIn) {
    this.psTNDialIn = psTNDialIn;
  }


  public ConferenceProvider meetingSetting(@javax.annotation.Nullable CreateConferenceProviderRequestMeetingSetting meetingSetting) {
    this.meetingSetting = meetingSetting;
    return this;
  }

  /**
   * Get meetingSetting
   * @return meetingSetting
   */
  @javax.annotation.Nullable
  public CreateConferenceProviderRequestMeetingSetting getMeetingSetting() {
    return meetingSetting;
  }

  public void setMeetingSetting(@javax.annotation.Nullable CreateConferenceProviderRequestMeetingSetting meetingSetting) {
    this.meetingSetting = meetingSetting;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConferenceProvider conferenceProvider = (ConferenceProvider) o;
    return Objects.equals(this.arn, conferenceProvider.arn) &&
        Objects.equals(this.name, conferenceProvider.name) &&
        Objects.equals(this.type, conferenceProvider.type) &&
        Objects.equals(this.ipDialIn, conferenceProvider.ipDialIn) &&
        Objects.equals(this.psTNDialIn, conferenceProvider.psTNDialIn) &&
        Objects.equals(this.meetingSetting, conferenceProvider.meetingSetting);
  }

  @Override
  public int hashCode() {
    return Objects.hash(arn, name, type, ipDialIn, psTNDialIn, meetingSetting);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConferenceProvider {\n");
    sb.append("    arn: ").append(toIndentedString(arn)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    ipDialIn: ").append(toIndentedString(ipDialIn)).append("\n");
    sb.append("    psTNDialIn: ").append(toIndentedString(psTNDialIn)).append("\n");
    sb.append("    meetingSetting: ").append(toIndentedString(meetingSetting)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Arn");
    openapiFields.add("Name");
    openapiFields.add("Type");
    openapiFields.add("IPDialIn");
    openapiFields.add("PSTNDialIn");
    openapiFields.add("MeetingSetting");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ConferenceProvider
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ConferenceProvider.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConferenceProvider is not found in the empty JSON string", ConferenceProvider.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ConferenceProvider.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConferenceProvider` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `Arn`
      if (jsonObj.get("Arn") != null && !jsonObj.get("Arn").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Arn"));
      }
      // validate the optional field `Name`
      if (jsonObj.get("Name") != null && !jsonObj.get("Name").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Name"));
      }
      // validate the optional field `Type`
      if (jsonObj.get("Type") != null && !jsonObj.get("Type").isJsonNull()) {
        ConferenceProviderType.validateJsonElement(jsonObj.get("Type"));
      }
      // validate the optional field `IPDialIn`
      if (jsonObj.get("IPDialIn") != null && !jsonObj.get("IPDialIn").isJsonNull()) {
        CreateConferenceProviderRequestIPDialIn.validateJsonElement(jsonObj.get("IPDialIn"));
      }
      // validate the optional field `PSTNDialIn`
      if (jsonObj.get("PSTNDialIn") != null && !jsonObj.get("PSTNDialIn").isJsonNull()) {
        CreateConferenceProviderRequestPSTNDialIn.validateJsonElement(jsonObj.get("PSTNDialIn"));
      }
      // validate the optional field `MeetingSetting`
      if (jsonObj.get("MeetingSetting") != null && !jsonObj.get("MeetingSetting").isJsonNull()) {
        CreateConferenceProviderRequestMeetingSetting.validateJsonElement(jsonObj.get("MeetingSetting"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConferenceProvider.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConferenceProvider' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConferenceProvider> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConferenceProvider.class));

       return (TypeAdapter<T>) new TypeAdapter<ConferenceProvider>() {
           @Override
           public void write(JsonWriter out, ConferenceProvider value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConferenceProvider read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ConferenceProvider given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ConferenceProvider
   * @throws IOException if the JSON string is invalid with respect to ConferenceProvider
   */
  public static ConferenceProvider fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConferenceProvider.class);
  }

  /**
   * Convert an instance of ConferenceProvider to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

